/*
 * Embedded native-code extension functions
 *
 * The ICI cfunc module provides a facility for embedding native code extension
 * functions within ICI source files.   The cfunc module defines a "[cfunc ...]"
 * literal which contains the C source code for native-code ICI functions.  The
 * cfunc module provides a parser extension function which extracts this code,
 * wraps it in an ICI native-code module structure and then calls the system C
 * compiler to build a dynamically loadable ICI module from the resultant C source
 * file.  The function, in its native-code ICI module form, is then dynamically loaded
 * into the ICI process.
 *
 * The "[cfunc ... ]" literal has the following form:
 *
 *      '[cfunc' c-identifier c-function-body ']'
 *
 * The c-identifier defines the name by which the extension function may be
 * referenced from within the ICI program.  The c-function-body is the
 * complete C source code for the extension function.   E.g.,  the following
 * defines a native code function that adds two, ICI, integers (which ICI
 * represents using C's long int type).
 *
 *      [cfunc add_two_integers
 *      {
 *          long a, b;
 *          if (ici_typecheck("ii", &a, &b))
 *              return 1;
 *          return ici_int_ret(a + b);
 *      }]
 *
 * When the above code is encountered during parsing of the ICI program
 * the function body is extracted and written to a temporary file which
 * is then compiled and an appropriate dynamic library constructed from
 * its object file.  The dynamic library is then loaded using ICI's
 * dynamic loading function, load().
 *
 * To avoid re-compilation a hash of the source code file is maintained
 * alongside the dynamic library file.  If the newly extracted source
 * code has an identical hash value to any existing hash then the module
 * is used as is.  Note that because comments are stripped from the
 * embedded source code simple changes in commentary will not result
 * in re-compilation.
 *
 * This --intro-- and --synopsis-- are part of --ici-cfunc-- documentation.
 */

/*
 *  Where temporary files live
 */
static tmpdir = getenv("TMPDIR") || "/tmp";

/*
 *  Directory where compiled modules reside.
 */
extern cfunc_module_directory = getenv("ICI_CFUNC_DIR") || ".ici";

/*
 *  Where to find ici.h
 */
extern ici_include_dir = "/usr/local/include";

/*
 *  Command name used to invoke the C compiler to have it
 *  produce a dynamic library suitable for loading into the
 *  running ICI interpreter process.
 */
extern c_compiler = "cc -pipe -shared";

/*
 *  Options to pass to the C compiler.
 */
extern c_compiler_options = "-Os";

/*
 *  Ensure the cfunc module directory exists
 */
try sys.mkdir(cfunc_module_directory); onerror NULL;

/*
 *  Pre-pend the cfunc module directory to the module search path
 */
rpush(path, pathjoin(sys.getcwd(), cfunc_module_directory));


/*
 *  Parser function for the [cfunc...] literal.  This is invoked
 *  by the ICI parser when it encounters a "[cfunc" token (sequence).
 *
 *  A cfunc literal is a named block of C code.  The code is used as
 *  the body of a C function that is wrapped in enough "glue" to
 *  permit the function to be loaded as a native code extension
 *  into the currently running ICI interpreter.
 *
 *  The cfunc function MUST obey ICI native-code function conventions,
 *
 */
extern parser()
{
    /*
     *  The parser's states.  The parser is a simple state machine that
     *  strips comments from the code and accumulates the non-comment code.
     *  Code must start with the sequence "[cfunc <identifier> {" and all
     *  code up to a terminating "}" is accumulated.  To let us find the
     *  real terminating "}" we have to skip comments and recognize string
     *  and character literals.
     */
    static IN_CODE = "1";
    static END_OF_CODE = "end";
    static GOT_SLASH = "/";
    static IN_MULTILINE_COMMENT = "/*";
    static STAR_INSIDE_COMMENT = "*";
    static IN_ONELINE_COMMENT = "//";
    static IN_STRING_LITERAL = "\"";
    static IN_CHAR_LITERAL = "'";

    auto not_followed_by(stmt, what)
    {
        fail(sprintf("%s not followed by %s", stmt, what));
    }

    if (parsetoken(currentfile()) != "name")
        not_followed_by("[cfunc", "an identifier");

    name := tokenobj(currentfile());

    if (parsetoken(currentfile()) != "{")
        not_followed_by("[cfunc <identifier>", "a \"{\"");

    code := array();
    nbrace := 1;
    esc := 0;
    for (state = IN_CODE; state != END_OF_CODE; )
    {
        c := getchar(currentfile());
        switch (state)
        {
        case IN_CODE:
            switch (c)
            {
            case "\"":
                state = IN_STRING_LITERAL;
                push(code, c);
                break;
            case "'":
                state = IN_CHAR_LITERAL;
                push(code, c);
                break;
            case "/":
                state = GOT_SLASH;
                break;
            case "{":
                ++nbrace;
                push(code, c);
                break;
            case "}":
                if (--nbrace == 0)
                {
                    state = END_OF_CODE;
                    break;
                }
                /*FALLTHROUGH*/
            default:
                push(code, c);
                break;
            }
            break;

        case IN_CHAR_LITERAL:
            switch (c)
            {
            case "\\":
                esc = 1 - esc;
                break;
            case "'":
                if (!esc)
                    state = IN_CODE;
                else
                    esc = 0;
                break;
            default:
                esc = 0;
                break;
            }
            push(code, c);
            break;

        case IN_STRING_LITERAL:
            switch (c)
            {
            case "\\":
                esc = 1 - esc;
                break;
            case "\"":
                if (!esc)
                    state = IN_CODE;
                else
                    esc = 0;
                break;
            default:
                if (esc)
                    esc = 0;
                break;
            }
            push(code, c);
            break;

        case GOT_SLASH:
            switch (c)
            {
            case "*":
                state = IN_MULTILINE_COMMENT;
                break;
            case "/":
                state = IN_ONELINE_COMMENT;
                break;
            default:
                push(code, "/");
                push(code, c);
                state = IN_CODE;
                break;
            }
            break;

        case IN_MULTILINE_COMMENT:
            switch (c)
            {
            case "*":
                state = STAR_INSIDE_COMMENT;
                break;
            }
            break;

        case STAR_INSIDE_COMMENT:
            switch (c)
            {
            case "/":
                state = IN_CODE;
                break;
            default:
                state = IN_MULTILINE_COMMENT;
                break;
            }
            break;

        case IN_ONELINE_COMMENT:
            switch (c)
            {
            case "\\":
                esc = 1 - esc;
                break;

            case "\n":
                if (!esc)
                    state = IN_CODE;
                break;

            default:
                esc = 0;
                break;
            }
            break;

        default:
            fail(sprintf("invalid parser state: \"%s\"", string(state)));
        }
    }

    code := sprintf
    (
        "#include <ici.h>\n"
        "\n"
        "static int f_%s(void)\n"
        "{\n"
        "%s"
        "}\n"
        "\n"
        "static ici_cfunc_t cfunc =\n"
        "{\n"
        "    ICI_CF_OBJ, \"%s\", f_%s\n"
        "};\n"
        "\n"
        "ici_obj_t *\n"
        "ici_%s_library_init(void)\n"
        "{\n"
        "    if (ici_interface_check(ICI_VER, ICI_BACK_COMPAT_VER, \"%s\"))\n"
        "        return NULL;\n"
        "    return ici_objof(&cfunc);\n"
        "}\n"
        "",

        name,
        implode(code),
        name,
        name,
        name,
        name
    );

    basicname := sprintf("%s-%d-%s", basename(argv[0]), sys.getpid(), name);
    filename := pathjoin(tmpdir, basicname + ".c");
    soname := pathjoin(cfunc_module_directory, "ici4" + name + ".so");
    hashname := soname + ".hash";

    file := fopen(filename, "w");
    printf(file, "%s", code);
    close(file);

    hash := md5.file(filename);

    try
    {
	sys.access(soname); // ensure the dynamic library exists
        file := fopen(hashname);  // ensure it has a recorded hash
        old_hash := getline(file);
        close(file);
        if (old_hash == hash) // and if the hashes match, use the existing module
        {
            remove(filename);
            return load(name);
        }
    }
    onerror
    {
        // If the above fails for any reason just compile
        // the generated source and use the result.
    }

    cmd := sprintf
    (
        "%s %s '-I%s' '%s' -o '%s'",
        c_compiler,
        c_compiler_options,
	ici_include_dir,
        filename,
        soname
    );
    status := system(cmd);
    remove(filename);
    if (status != 0)
        fail("compile failed");

    file := fopen(hashname, "w");
    printf(file, "%s\n", hash);
    close(file);

    return load(name);
}
