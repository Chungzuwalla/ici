/*
 * $Id: ici4PostgreSQL.ici,v 1.2 2003/05/20 00:44:05 atrn Exp $
 */

/*
 * The ICI PostgreSQL module provides access to the PostgreSQL DBMS
 * via its 'libpq' C library.
 *
 * The module has two interfaces, a low-level interfaces that makes
 * the PostgreSQL libpq functions available to ICI and an OO interface
 * that uses ICI classes to represent PostgreSQL objects such as
 * Connections, Results, Tables, etc...  The low-level interface is
 * written in C and maps libpq to ICI types whilst the OO interface
 * is written in ICI using the low-level interface to access PostgreSQL.
 *
 * This --intro-- forms part of the --ici-PostgreSQL-- documentation.
 */

/*
 * Error Codes
 *
 * All of the error codes listed in the PostgreSQL C header files are
 * made available to ICI as pre-defined variables in the PostgreSQL
 * module.
 *
 * This --topic-- forms part of the --ici-PostgreSQL-- documentation.
 */
extern	CONNECTION_OK		     = 0,
	CONNECTION_OKAY		     = 0,
	CONNECTION_BAD		     = 1,
	CONNECTION_STARTED	     = 2,
	CONNECTION_MADE		     = 3,
	CONNECTION_AWAITING_RESPONSE = 4,
	CONNECTION_AUTH_OK	     = 5,
	CONNECTION_AUTH_OKAY	     = 5,
	CONNECTION_SETENV	     = 6,

	PGRES_POLLING_FAILED	     = 0,
	PGRES_POLLING_READING	     = 1,
	PGRES_POLLING_WRITING	     = 2,
	PGRES_POLLING_OK	     = 3,
	PGRES_POLLING_OKAY	     = 3,
	PGRES_POLLING_KACTIVE	     = 4,

	PGRES_EMPTY_QUERY	     = 0,
	PGRES_COMMAND_OK	     = 1,
	PGRES_COMMAND_OKAY	     = 1,
	PGRES_TUPLES_OK		     = 2,
	PGRES_TUPLES_OKAY	     = 2,
	PGRES_COPY_OUT		     = 3,
	PGRES_COPY_IN		     = 4,
	PGRES_BAD_RESPONSE	     = 5,
	PGRES_NONFATAL_ERROR	     = 6,
	PGRES_FATAL_ERROR	     = 7;


/*
 * string = PostgreSQL.escape_string(string)
 *
 * Escapes single quotes found in strings.
 * 
 * This --function-- forms part of the --ici-PostgreSQL-- documentation.
 */
extern
escape_string(str)
{
    return gsub(str, "(')", "\\\\\\&");
}


/*
 * A connection to a PostgreSQL database.
 *
 * This --topic-- forms part of the --ici-PostgreSQL-- documentation.
 */
extern
Connection = [class

    /*
     * Connection:new(string)
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    new(connection_info)
    {
	this = this:^new();
	this.m_conn := PostgreSQL.connectdb(connection_info);
	return this;
    }

    /*
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    defaults()
    {
	return PostgreSQL.conndefaults();
    }

    /*
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    trace(file)
    {
	auto file = stderr;
	PostgreSQL.trace(m_conn, file);
	return this;
    }

    /*
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    untrace()
    {
	PostgreSQL.untrace(m_conn);
	return this;
    }

    /*
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    status()
    {
	return PostgreSQL.status(m_conn);
    }

    /*
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    finish()
    {
	PostgreSQL.finish(m_conn);
	return this;
    }

    /*
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    reset()
    {
	PostgreSQL.reset(m_conn);
	return this;
    }

    /*
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    db()
    {
	return PostgreSQL.db(m_conn);
    }

    /*
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    user()
    {
	return PostgreSQL.user(m_conn);
    }

    /*
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    pass()
    {
	return PostgreSQL.pass(m_conn);
    }

    /*
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    host()
    {
	return PostgreSQL.host(m_conn);
    }

    /*
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    port()
    {
	return PostgreSQL.port(m_conn);
    }
    
    /*
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    tty()
    {
	return PostgreSQL.tty(m_conn);
    }
    
    /*
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    options()
    {
	return PostgreSQL.options(m_conn);
    }

    /*
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    error_message()
    {
	return PostgreSQL.errorMessage(m_conn);
    }

    /*
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    socket()
    {
	return PostgreSQL.socket(m_conn);
    }

    /*
     * Result = Connection:exec(string)
     * Result = Connection:exec(string, array)
     *
     * Execute an SQL statement and return a Result object holding the
     * result of that execution.
     *
     * The first form takes one or more SQL statements, separated by semi-colons, and
     * executes them.  Any values must be represented in the statement as text.  Note
     * that because of this so-called "SQL injection attacks" are possible if care is
     * not taken to validate the input (which may be difficult).
     *
     * The second form separates the statement from any values that are used within
     * the statement.  The statement uses placeholders ("$1", "$2", etc...) to refer
     * to parameters that are substituted into the statement.  Parameters values are
     * taken from the array with $1 referring to the 0'th element, $2 the 1st element
     * and so on.
     *
     * The second form permits only a single SQL statement to be executed.
     *
     * The second form may be more efficient as integer and floating point data
     * is sent in its internal represetation and not converted to text.
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    exec(stmt, param)
    {
        return Result:new
	(
	    param ? PostgreSQL.exec(m_conn, stmt, param) : PostgreSQL.exec(m_conn, stmt)
	);
    }

    /*
     * array = Connection:query(string)
     * array = Connection:query(string, parameters)
     *
     * Calls exec() to execute an SQL statement and returns an array containing
     * the rows of the result.   The first form uses the single argument form
     * of exec() whilst the second form calls the two argument form of exec(),
     * and therefor performing argument substitution.
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    query()
    {
        auto vargs;
        r := call(this:exec, vargs);
        status := r:status();
        if (status != PGRES_COMMAND_OK && status != PGRES_TUPLES_OK)
            r:failed();
        return r:rows();
    }

    /*
     * array = Connection:select(string)
     * array = Connection:select(string, array)
     *
     * Executes an SQL SELECT statement and returns an array of results.
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    select(clause, args)
    {
        return args ? (this:query("SELECT " + clause, args)) : (this:query("SELECT " + clause));
    }

    /*
     * Table = Connection:table(string)
     *
     * Returns a Table object representing the table with the given name.
     */
    table(name)
    {
        return Table:new(this, name);
    }

    /*
     * Connection::insert(string, values)
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    insert(tablespec, valuespec)
    {
	sql = sprintf
	(
	    "INSERT INTO %s VALUES (%s)",
	    tablespec,
	    valuespec
	);
	result = this:exec(sql);
        try
	    if (result:status() != PGRES_COMMAND_OK)
                result:failed();
        onerror
            fail("failed getting result status");
    }

    /*
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    update(table, fields, values)
    {
	sql = sprintf
	(
	    "UPDATE %s SET %s = %s",
	    table,
	    fields,
	    values
	);
	result = this:exec(sql);
	if (result:status() != PGRES_COMMAND_OK)
	    result:failed();
    }

];


/*
 * A holder for a reference to a table held in a database.
 *
 * This --topic-- forms part of the --ici-PostgreSQL-- documentation.
 */
extern
Table = [class

    /*
     * Table:new(Connection, string)
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    new(conn, name)
    {
        this = this:^new();
        this.m_conn := conn;
        this.m_name := name;
        return this;
    }

    /*
     * Table:insert(array)
     *
     * This --function-- forms part of the --ici-PostgreSQL-- documentation.
     */
    insert(values)
    {
        stmt := sprintf("INSERT INTO %s ", m_name);
        conn:exec(stmt, values);
    }

];


/*
 * A holder for the result of a PostgreSQL exec call.
 *
 * This --topic-- forms part of the --ici-PostgreSQL-- documentation.
 */
extern
Result = [class

    new(r)
    {
	this = this:^new();
	this.m_result := r;
	return this;
    }

    status()
    {
	return PostgreSQL.resultStatus(m_result);
    }

    sstatus(code)
    {
	return PostgreSQL.resStatus(code ? code : this:status());
    }

    error_message()
    {
	return PostgreSQL.resultErrorMessage(m_result);
    }

    failed()
    {
	fail(this:sstatus());
    }

    cmd_status()
    {
	return PostgreSQL.cmdStatus(m_result);
    }

    oid_status()
    {
	return PostgreSQL.oidStatus(m_result);
    }
    
    oid_value()
    {
	return PostgreSQL.oidValue(m_result);
    }
    
    cmd_tuples()
    {
	return PostgreSQL.cmdTuples(m_result);
    }
    
    ntuples()
    {
	return PostgreSQL.ntuples(m_result);
    }
    
    nfields()
    {
	return PostgreSQL.nfields(m_result);
    }
    
    binary_tuples()
    {
	return PostgreSQL.binaryTuples(m_result);
    }

    fname(idx)
    {
	return PostgreSQL.fname(m_result, idx);
    }

    fnumber(nam)
    {
	return PostgreSQL.fnumber(m_result, nam);
    }

    ftype(idx)
    {
	return PostgreSQL.ftype(m_result, idx);
    }
    
    fsize(idx)
    {
	return PostgreSQL.fsize(m_result, idx);
    }
    
    fmod(idx)
    {
	return PostgreSQL.fmod(m_result, idx);
    }

    getvalue(tup, fld)
    {
	return PostgreSQL.getvalue(m_result, tup, fld);
    }

    getlength(tup, fld)
    {
	return PostgreSQL.getlength(m_result, tup, fld);
    }

    getisnull(tup, fld)
    {
	return PostgreSQL.getisnull(m_result, tup, fld);
    }

    /*
     * array = Result:rows()
     *
     * Return the rows of the result as an array of structs where
     * each struct has the result's column names as keys.
     */
    rows()
    {
	column_names := array();
	result_rows := array();
	num_columns := this:nfields();
	for (i := 0; i < num_columns; ++i)
	    column_names[i] = this:fname(i);
	for (i := 0, n := this:ntuples(); i < n; ++i)
	{
            row := struct();
	    for (j := 0; j < num_columns; ++j)
		row[column_names[j]] = str.trim(this:getvalue(i, j));
	    push(result_rows, row);
	}
	return result_rows;
    }

];
