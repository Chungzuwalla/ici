/*
 * $Id: ici4sys.ici,v 1.1 2003/01/05 09:40:55 timl Exp $
 *
 * System module portions more easily done in ICI than C.
 */


export	SIGHUP	= 1;	/* hangup */
export	SIGINT	= 2;	/* interrupt */
export	SIGQUIT	= 3;	/* quit */
export	SIGILL	= 4;	/* illegal instruction (not reset when caught) */
export	SIGTRAP	= 5;	/* trace trap (not reset when caught) */
export	SIGABRT	= 6;	/* abort() */
export	SIGIOT	= SIGABRT;	/* compatibility */
export	SIGEMT	= 7;	/* EMT instruction */
export	SIGFPE	= 8;	/* floating point exception */
export	SIGKILL	= 9;	/* kill (cannot be caught or ignored) */
export	SIGBUS	= 10;	/* bus error */
export	SIGSEGV	= 11;	/* segmentation violation */
export	SIGSYS	= 12;	/* non-existent system call invoked */
export	SIGPIPE	= 13;	/* write on a pipe with no one to read it */
export	SIGALRM	= 14;	/* alarm clock */
export	SIGTERM	= 15;	/* software termination signal from kill */
export	SIGURG	= 16;	/* urgent condition on IO channel */
export	SIGSTOP	= 17;	/* sendable stop signal not from tty */
export	SIGTSTP	= 18;	/* stop signal from tty */
export	SIGCONT	= 19;	/* continue a stopped process */
export	SIGCHLD	= 20;	/* to parent on child stop or exit */
export	SIGTTIN	= 21;	/* to readers pgrp upon background tty read */
export	SIGTTOU	= 22;	/* like TTIN for output if (tp->t_local&LTOSTOP) */
export	SIGIO	= 23;	/* input/output possible signal */
export	SIGXCPU	= 24;	/* exceeded CPU time limit */
export	SIGXFSZ	= 25;	/* exceeded file size limit */
export	SIGVTALRM = 26;	/* virtual time alarm */
export	SIGPROF	= 27;	/* profiling time alarm */
export	SIGWINCH = 28;	/* window size changes */
export	SIGINFO	= 29;	/* information request */
export	SIGUSR1 = 30;	/* user defined signal 1 */
export	SIGUSR2 = 31;	/* user defined signal 2 */

export	SIG_DFL	= 0;
export	SIG_IGN	= 1;
export	SIG_ERR	= -1;


/*
 * Resource limits
 */
export RLIMIT_CPU = 0;		/* cpu time in milliseconds */
export RLIMIT_FSIZE = 1;	/* maximum file size */
export RLIMIT_DATA = 2;		/* data size */
export RLIMIT_STACK = 3;	/* stack size */
export RLIMIT_CORE = 4;		/* core file size */
export RLIMIT_RSS = 5;		/* resident set size */
export RLIMIT_MEMLOCK = 6;	/* locked-in-memory address space */
export RLIMIT_NPROC = 7;	/* number of processes */
export RLIMIT_NOFILE = 8;	/* number of open files */
export RLIMIT_SBSIZE = 9;	/* maximum size of all socket buffers */

export RLIM_INFINITY = -1;

/*
 * Retrieve all resource limits and return in a struct
 */
export
getrlimits()
{
    resources = [set "cpu", "fsize", "data", "stack", "core",
		     "rss", "memlock", "nproc", "nofile", "sbsize"];
    rc = struct();
    forall (resource in resources)
	rc[resource] = getrlimit(resource);
    return rc;
}
