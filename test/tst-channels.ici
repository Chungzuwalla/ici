//  Runs Nworkers workers, each reading from a workq channel.
//  Each worker reads a "job" from workq, does some simulated
//  work and records stats - the last job it did and increments
//  its count of the number of jobs.
//
//  We send Njobs jobs "down" the work queue, close it and
//  wait for the workers to finish. One of them should have
//  processed the last job. The sum of the number of jobs
//  each did should be the same as the total number of jobs.
//

Njobs := int(argv[1]) || (5*1000);
Nworkers := int(argv[2]) || 4;
Nqueue := int(argv[3]) || 2;
verbose := getenv("verbose");

rand(Njobs * Nworkers);

local Ndone = array();
local Lastjob = array();

for (i := 0; i < Nworkers; ++i) {
    Ndone[i] = 0;
    Lastjob[i] = 0;
}

local work(job, workerid) {
    Lastjob[workerid] = job;
    limit := 1 + rand() % 1000;
    for (i := 0; i < limit; ++i) {
	job += cos(float(workerid * i / limit));
    }
    ++Ndone[workerid];
}

local runq(ch, workerid) {
    forall (fn in ch) {
        fn(workerid);
    }
}

workq := channel(Nqueue);

workers := array();
for (id := 0; id < Nworkers; ++id) {
    worker := go(runq, workq, id);
    push(workers, worker);
}

for (x := 1; x <= Njobs; ++x) {
    put(workq, closure(work, x));
}

close(workq);

forall (worker in workers) {
    waitfor(worker.status == "finished"; worker);
}

// Check things

local failures = 0;

maxjob := call(max, Lastjob);
if (maxjob != Njobs) {
    printf(stderr, "expected last job == 'Njobs': last=%s Njobs=%d", string(maxjob), Njobs);
    ++failures;
}

totaljobs := 0;
forall (v, k in Ndone) {
    verbose && printf("worker:%d did %d jobs\n", k+1, v);
    totaljobs += v;
}
if (totaljobs != Njobs) {
    printf(stderr, "total # jobs %d != %d, the number sent\n", totaljobs, Njobs);
    ++failures;
}

for (id := 0; id < Nworkers; ++id) {
    if (Ndone[id] == 0) {
	printf("worker %d completely starved\n", id+1);
	failed = true;
    }
}

exit(failures > 0);
